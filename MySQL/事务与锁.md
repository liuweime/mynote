# 高性能MySQL阅读笔记 | 事务与锁

## 一 事务

事务应该是一个独立的单元，执行的操作要么全部完成，要么全部失败

### 1.1 事务的特性

- 原子性：事务被认为是一个不可分割的单元，事务所做的操作要么是全部成功，要么是全部失败
- 一致性：事务必须保证操作后的数据库保持一致性状态
- 隔离性：事务执行的操作在提交之前对其他事务是不可见的
- 持久性：事务提交后会被永久保存到数据库中

### 1.2 事务的隔离级别

- 未提交读
- 提交读
- 可重复读
- 可串行化

未提交读(read uncommitted)：事务A可以读取到事务B中未提交的修改，这是事务隔离的最低级别，能够导致`脏读`

提交读(read committed)：事务A可以读取到事务B提交后的修改，会导致`不可重读`

可重复读(repeatable read)：事务B所做的更新对事务A是不可见得。这样，事务A相同的查询就会返回相同的结果，但是会导致`幻读`

串行化(serilizable)：最高的隔离级别，各个事务之间是隔离的，可以避免脏读、不可重读，幻读等


#### 1.2.1 脏读、幻读、不可重复读

**脏读：**事务可以读取到事务未提交的数据

通过银行打款进行举例：

> 同学A要给B打款5000，在打款时按错变成6000(未确认)，此时B查询余额发现账号余额6000

这就是未提交读，B读取的数据就是`脏读`。要解决脏读就要提高隔离级别

**不可重读：**同一个事务两次查询结果不一致

> A给B打款5000(事务A开始)，系统查询余额13000，同时A妻子看中一款包包(事务B开始)，消费10000(事务B提交)，A确定打款，银行查询余额，提示余额不足

一个事务中两次相同查询返回不同结果，这就是不可重复读。解决不可重复读，同样要提高事务隔离级别

**幻读：**

维基中的定义，它是一种特殊的不可重复读，同一个事务两次完全相同的查询得到了不同的结果集。更为清晰的解释是，事务读取某个范围的记录时，其他事务在该范围插入了新的记录，当这个事务再次读取该范围的记录，会产生幻行。

这里注意不可重读和幻读的区别，不可重读是查询某条数据返回不一致的结果，幻读是查询范围记录返回不一致的结果集。

#### 1.2.2 MySQL中的`REPEATABLE READ`能不能避免幻读


上面介绍`repeatable read`导致了**幻读**的产生。

如果你有搜索过关于MySQL幻读的问题，可以看到很多种说法，有人说MySQL的RR级别解决了幻读，有人说RR级别导致幻读，MySQL并没有解决这个问题，并用实验进行了严谨的说明。

下面把网上同学所做的实验列出来：

首先说明环境，`MySQL`数据库，`Innodb`引擎，建表语句如下

```SQL
CREATE TABLE `read_test` (
  `id` INT UNSIGNED AUTO_INCREMENT COMMENT '主键',
  `num` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '数量',
  PRIMARY KEY (`id`)
) ENGINE=Innodb CHARSET=utf8 COMMENT '测试表';

-- 插入数据
INSERT INTO `read_test` (num) value (10);
INSERT INTO `read_test` (num) value (20);
INSERT INTO `read_test` (num) value (30);
INSERT INTO `read_test` (num) value (40);
INSERT INTO `read_test` (num) value (50);
```
测试开始

测试一：


| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `SELECT * FROM read_test WHERE id > 2`(3条数据)  |
|                                                 | `INSERT INTO read_test (num) value (60);`
|                                                 | `commit`
| `SELECT * FROM read_test WHERE id > 2`(3条数据，且结果和第一次查询一致)  |

测试一可以看出，这里确实没有出现幻读。那么请看测试二

测试二：

上面事务A没有提交，这里继续实验
| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `INSERT INTO read_test (id,num) value (6,60);`(执行失败)  |
| `commit`

上面实验语句报出的错误是`ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'`，明明事务A查询只有3，4，5三条数据，那么插入id=6居然插入失败了，这是产生幻读了？再看测试三

测试三：

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `SELECT num FROM read_test WHERE id=1;`(num=20) | `SELECT num FROM read_test WHERE id=1;`(num=20) |
|                                                 | `UPDATE read_test SET num=2 WHERE id=1`         |
| `SELECT num FROM read_test WHERE id=1;`(num=20) |                                                 |
|                                                 | `commit`                                        |
| `SELECT num FROM read_test WHERE id=1;`(num=20) |                                                 |
| `UPDATE read_test SET num=num-1 where id=1`     |                                                 |
| `SELECT num FROM read_test WHERE id=1;`(num=1)  |                                                 |

查询`id=1`得到num值是20，做减一的更新操作后再次查询结果num值变成1了，这算不算幻读？

测试二和测试三是网上同学经常举的两个例子，甚至有人把这个问题（实验三）作为bug向MySQL开发团体提交。有兴趣的请看[Repeatable-read isolation violated in UPDATE](https://bugs.mysql.com/bug.php?id=63870)。

按照严格的幻读定义，MySQL的RR级别确实解决了幻读问题

> 在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻影读（phantom read）”
当事务没有获取范围锁的情况下执行SELECT ... WHERE操作可能会发生“幻影读”。

事实上，在其他数据库中实验一时已经会发生幻读现象，实验无法进行到二和三。这是由于MySQL的RR级别实现机制和其他数据库不同。

这里就要说到MySQL的`MVCC`机制，`MVCC`即多版本控制系统，在不同数据库中均有实现，当然表现各不一致。MVCC保存了版本快照，启动事务时，版本自动递增，同时**事务中仅能读取到当前及以前的版本**，这就是我们所说的**快照读**。 所以RR级别进入事务，仅能读取到开始事务前和当前事务中所作的修改。这样的好处是保证读不加锁，读写不冲突，提高了并发性能。

因为进入事务中读取的是快照库，而这种快照读仅运用于`SELECT`中，不影响到其他DML语句（insert/update/delete），下面是官方文档做的说明：

> The snapshot of the database state applies to SELECT statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a DELETE or UPDATE statement issued from another concurrent REPEATABLE READ transaction could affect those just-committed rows, even though the session could not query them. If a transaction does update or delete rows committed by a different transaction, those changes do become visible to the current transaction

如果你希望在RR级别解决广义上的幻读，就需要使用到**当前读**，**当前读**读取得是记录的最新版本。对查询进行加锁后，进行的就是当前读，这里其他事务的DML操作就会被阻塞，见下面测试：

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `SELECT * FROM read_test WHERE id > 2 FOR UPDATE`(3条数据)  |
|                                                 | `INSERT INTO read_test (num) value (60);`

此时，事务B会被阻塞，直到事务A被提交或超时。当然此时的并发性能会降低很多，这可能是`serilizable`所做的一部分工作。

## 二 锁

- 锁是为了解决并发中的数据冲突问题
- 使用共享锁和排他锁解决数据冲突问题(并发控制)
- 有效的锁策略以提高并发性能(行级锁与表级锁)

### 2.1 锁种类

- 行级锁
  + 共享锁(S)
  + 排他锁(X)
- 表级锁
  + 意向共享锁(IS)
  + 意向排他锁(IX)

**共享锁**，简称S锁，行级锁的一种，多个事务对同一数据都能够进行读取，但是不能修改(其他事务)，所以又被叫做读锁。
**排他锁**，简称X锁，该锁不能多个事务共享，当一个事务获得X锁后，其他事务只能等待锁放开才能进行修改数据，所以被叫做写锁。
**意向共享锁**，简称IS锁，事务获取该锁，表示该事务意向在某行数据上加S锁
**意向排他锁**，简称IX锁，事务获取该锁，表示该事务意向在某行数据上加X锁
**乐观锁**：乐观锁先假设不会发生并发冲突，在提交操作时检查是否违反数据完整性。
**悲观锁**：悲观锁和乐观锁不同，先假设一定会发生冲突，所以事先对数据进行加锁。它的实现依赖于数据库的锁机制。

### 2.2 MySQL的锁机制

**Gap lock：**间隙锁，锁定一个范围。即使这个范围内某个值不存在与表中。从官方文档中看出，通常间隙锁针对于非唯一索引的情况。在事务中，更新或删除某行记录时，若指定条件是非唯一索引，该记录的间隙会被加锁(间隙锁)。
**Record lock：**记录锁，该锁叫做记录锁，实际上针对的是索引记录，永远只是对索引记录加锁，如果没有索引，会对聚簇索引加锁（这时相当于整个表被锁，但和表锁机制不一样）
**Next-key lock：**记录锁和间隙锁的组合


### 2.3 那些情况下MySQL会进行加锁，如何手动进行加锁

`INSERT`,`UPDATE`,`DELETE`执行时会对涉及的行加锁排他锁(x)，`SELECT`一般不会被加锁

使用`for update`添加排他锁，`lock in share mode`添加共享锁

下面演示一下InnoDb在RR级别下的加锁：
还是上面的`read_test`表，`id`主键，唯一索引，`num`没有索引，插入数据

```sql
INSERT INTO `read_test` (num) value (10);
INSERT INTO `read_test` (num) value (20);
INSERT INTO `read_test` (num) value (30);
INSERT INTO `read_test` (num) value (40);
```

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `UPDATE read_test SET num=0 WHERE id=20`
|                                                 | `INSERT INTO read_test (num) VALUE (25)`

`id`是唯一索引，所以此时没有加锁，事务B能够正常执行。`rollback`后继续试验

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `UPDATE read_test SET id=20 WHERE num=20`
|                                                 | `INSERT INTO read_test (num) VALUE (25)`

`num`没有索引，此时`num=20`的间隙被加上间隙锁，事务B被阻塞了。而这个间隙的范围是[10,30)。

另外，如果此时查询没有使用到任何索引，整个表范围内会被加上锁，这里删除掉id的主键（通过`show OPEN TABLES where In_use > 0`查询此时表没有被锁）
| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `UPDATE read_test SET num=0 WHERE id=20`
|                                                 | `INSERT INTO read_test (id,num) VALUE (1,0)`
|                                                 | `INSERT INTO read_test (id,num) VALUE (10,0)`
|                                                 | `INSERT INTO read_test (id,num) VALUE (30,0)`

上面三条插入均被阻塞。

### 2.4 如何构建乐观锁和悲观锁？


### 2.5 死锁是什么？死锁发生场景，如何避免死锁


[mysql死锁问题分析](http://www.cnblogs.com/LBSer/p/5183300.html)
[mysql-Innodb事务隔离级别-repeatable read详解](https://blog.csdn.net/dong976209075/article/details/8802778)
[理解事务的4种隔离级别](https://blog.csdn.net/qq_33290787/article/details/51924963)
[mysql的可重复读REPEATABLE READ隔离级别和幻读](https://blog.csdn.net/huyangyamin/article/details/46848875)
[MySQL · 源码分析 · InnoDB Repeatable Read隔离级别之大不同](http://mysql.taobao.org/monthly/2017/06/07/)
[Mysql中那些锁机制之InnoDB](https://www.2cto.com/database/201508/429967.html)
[MySQL 加锁处理分析](http://hedengcheng.com/?p=771)
[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/innodb-lock.html)
[Innodb 中 RR 隔离级别能否防止幻读？](https://github.com/Yhzhtk/note/issues/42)
[搞懂 不可重复读和幻读](https://segmentfault.com/a/1190000012669504)
[mysql的锁--行锁，表锁，乐观锁，悲观锁](https://www.cnblogs.com/deliver/p/5730616.html)
[MySQL MVCC原理](https://www.cnblogs.com/chinesern/p/7592537.html)
[使用mysql悲观锁解决并发问题](https://www.cnblogs.com/laoyeye/p/8228467.html)
[MySQL乐观锁在分布式场景下的实践](https://segmentfault.com/a/1190000008935924)
[mysql乐观锁总结和实践](https://www.2cto.com/database/201704/632115.html)
[Mysql加锁过程详解（7）-初步理解MySQL的gap锁](https://www.cnblogs.com/crazylqy/p/7689447.html)
[InnoDB的锁](http://leekai.me/lock-in-innodb/)
[InnoDB的锁机制](http://wiki.xiaohansong.com/db/innoDB_lock.html)
[Multiple granularity locking](https://en.wikipedia.org/wiki/Multiple_granularity_locking)
[常见的 InnoDB 锁介绍](https://juejin.im/post/5a2564c3f265da4325292473)
[一致性读分析](https://www.cnblogs.com/renolei/p/5910060.html)
[Mysql加锁过程详解（7）-初步理解MySQL的gap锁](https://www.cnblogs.com/crazylqy/p/7689447.html)