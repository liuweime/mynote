# 事务与锁

## 事务

事务应该是一个独立的单元，执行的操作要么全部完成，要么全部失败

### 事务的特性

- 原子性：事务被认为是一个不可分割的单元，事务所做的操作要么是全部成功，要么是全部失败
- 一致性：事务必须保证操作后的数据库保持一致性状态
- 隔离性：事务执行的操作在提交之前对其他事务是不可见的
- 持久性：事务提交后会被永久保存到数据库中

### 事务的隔离级别

- 未提交读
- 提交读
- 可重复读
- 可串行化

未提交读(read uncommitted)：事务A可以读取到事务B中未提交的修改，这是事务隔离的最低级别，能够导致`脏读`

提交读(read committed)：事务A可以读取到事务B提交后的修改，会导致`不可重读`

可重复读(repeatable read)：事务B所做的更新对事务A是不可见得。这样，事务A相同的查询就会返回相同的结果，但是会导致`幻读`

串行化(serilizable)：最高的隔离级别，各个事务之间是隔离的，可以避免脏读、不可重读，幻读等


#### 脏读、幻读、不可重复读

**脏读：**事务可以读取到事务未提交的数据

通过银行打款进行举例：

> 同学A要给B打款5000，在打款时按错变成6000(未确认)，此时B查询余额发现账号余额6000

这就是未提交读，B读取的数据就是`脏读`。要解决脏读就要提高隔离级别

**不可重读：**同一个事务两次查询结果不一致

> A给B打款5000(事务A开始)，系统查询余额13000，同时A妻子看中一款包包(事务B开始)，消费10000(事务B提交)，A确定打款，银行查询余额，提示余额不足

一个事务中两次相同查询返回不同结果，这就是不可重复读。解决不可重复读，同样要提高事务隔离级别

**幻读：**

维基中的定义，它是一种特殊的不可重复读，同一个事务两次完全相同的查询得到了不同的结果集。更为清晰的解释是，事务读取某个范围的记录时，其他事务在该范围插入了新的记录，当这个事务再次读取该范围的记录，会产生幻行。

#### MySQL中的`REPEATABLE READ`能不能避免幻读


上面介绍`repeatable read`导致了**幻读**的产生，值得注意的是，MySQL数据库中的Innodb引擎的`repeatable read`和标准不一致，它通过`MVCC`解决传统意义上的幻读。

那么问题来了，MySQL的Innodb是否确实解决了幻读呢？可以通过模拟实验来完成：

首先说明环境,`MySQL`数据库，`Innodb`引擎，建表语句如下

```SQL
CREATE TABLE `read_test` (
  `id` INT UNSIGNED AUTO_INCREMENT COMMENT '主键',
  `num` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '数量',
  PRIMARY KEY (`id`)
) ENGINE=Innodb CHARSET=utf8 COMMENT '测试表';

-- 插入数据
INSERT INTO `read_test` (num) value (10);
INSERT INTO `read_test` (num) value (20);
INSERT INTO `read_test` (num) value (30);
INSERT INTO `read_test` (num) value (40);
INSERT INTO `read_test` (num) value (50);
```
测试开始

测试一：


| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `SELECT * FROM read_test WHERE id > 2`(3条数据)  |
|                                                 | `INSERT INTO read_test (num) value (60);`
|                                                 | `commit`
| `SELECT * FROM read_test WHERE id > 2`(3条数据)  |

测试一可以看出，这里确实没有出现幻读。那么请看测试二

测试二：

上面事务A没有提交，这里继续实验
| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `INSERT INTO read_test (id,num) value (6,60);`(执行失败)  |
| `commit`

当上次语句报出错误`ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'`，明明事务A查询只有3，4，5三条数据，那么插入id=6居然插入失败了。再看测试三

测试三：

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `SELECT num FROM read_test WHERE id=1;`(num=20) | `SELECT num FROM read_test WHERE id=1;`(num=20) |
|                                                 | `UPDATE read_test SET num=2 WHERE id=1`         |
| `SELECT num FROM read_test WHERE id=1;`(num=20) |                                                 |
|                                                 | `commit`                                        |
| `SELECT num FROM read_test WHERE id=1;`(num=20) |                                                 |
| `UPDATE read_test SET num=num-1 where id=1`     |                                                 |
| `SELECT num FROM read_test WHERE id=1;`(num=1)  |                                                 |

查询`id=1`得到num值是20，做减一的更新操作后再次查询结果num值变成1了。

甚至有人把这个问题作为bug向MySQL开发团体提交，当然官方人员解释清楚了这并不是bug，这种幻读现象对于REPATABLE READ隔离级别也是正确的方式。有兴趣的请看[Repeatable-read isolation violated in UPDATE](https://bugs.mysql.com/bug.php?id=63870)。

测试二和测试三的结果显示Innodb的RR级别虽然似乎解决了一部分幻读问题。

说到这里，就不得不说MySQL的`MVCC`机制了，`MVCC`多版本控制系统，在不同数据库中均有实现，当然表现各不一致。MVCC保存了版本快照，启动事务时，版本自动递增，同时事务中仅能读取到当前及以前的版本，这就是我们所说的**快照读**。 所以RR级别进入事务，仅能读取到开始事务前和当前事务中所作的修改。这样的好处是除了解决了幻读，同时保证读不加锁，读写不冲突，提高了并发性能。

当然，快照读并不能完全解决幻读的产生，如果要解决幻读，可以使用当前读，这里就要进行加Gap锁。使用当前读以后，相关列的update/delete/insert操作就会被阻塞。见下面测试四：

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| `begin`                                         | `begin`
| `SELECT * FROM read_test WHERE id > 2 FOR UPDATE`(3条数据)  |
|                                                 | `INSERT INTO read_test (num) value (60);`

此时，事务B会被阻塞。


## 锁

- 锁是为了解决并发中的数据冲突问题
- 使用共享锁和排他锁解决数据冲突问题(并发控制)
- 有效的锁策略以提高并发性能(行级锁与表级锁)

### 锁种类

- 行级锁
  + 共享锁(S)
  + 排他锁(X)
- 表级锁
  + 意向共享锁(IS)
  + 意向排他锁(IX)

共享锁，简称S锁，行级锁的一种，多个事务对同一数据都能够进行读取，但是不能修改(其他事务)，所以又被叫做读锁。
排他锁，简称X锁，该锁不能多个事务共享，当一个事务获得X锁后，其他事务只能等待锁放开才能进行修改数据，所以被叫做写锁。

乐观锁和悲观锁

这两种锁并不是实际的锁，它们通常需要认为构建。
乐观锁：乐观锁先假设不会发生并发冲突，在提交操作时检查是否违反数据完整性。
悲观锁：悲观锁和乐观锁不同，先假设一定会发生冲突，所以会对数据进行加锁。它的实现依赖于数据库的锁机制。

### MySQL的锁机制

- Gap lock：间隙锁
- Record lock：行锁
- Next-key lock：行锁和间隙锁组合起来

`Recod Lock`锁定一行记录，`Gap lock`

### 那些情况下MySQL会进行加锁，如何手动进行加锁

`INSERT`,`UPDATE`,`DELETE`执行时会对涉及的行加锁排他锁(x)，`SELECT`一般不会被加锁

使用`for update`添加排他锁，`lock in share mode`添加共享锁

### 如何构建乐观锁和悲观锁？


### 死锁是什么？死锁发生场景，如何避免死锁

[mysql死锁问题分析](http://www.cnblogs.com/LBSer/p/5183300.html)
[mysql-Innodb事务隔离级别-repeatable read详解](https://blog.csdn.net/dong976209075/article/details/8802778)
[理解事务的4种隔离级别](https://blog.csdn.net/qq_33290787/article/details/51924963)
[mysql的可重复读REPEATABLE READ隔离级别和幻读](https://blog.csdn.net/huyangyamin/article/details/46848875)
[MySQL · 源码分析 · InnoDB Repeatable Read隔离级别之大不同](http://mysql.taobao.org/monthly/2017/06/07/)
[MySQL InnoDB锁机制之Gap Lock、Next-Key Lock、Record Lock解析](http://blog.sina.com.cn/s/blog_a1e9c7910102vnrj.html)
[Mysql中那些锁机制之InnoDB](https://www.2cto.com/database/201508/429967.html)
[MySQL 加锁处理分析](http://hedengcheng.com/?p=771)
[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/innodb-lock.html)
[Innodb 中 RR 隔离级别能否防止幻读？](https://github.com/Yhzhtk/note/issues/42)
[搞懂 不可重复读和幻读](https://segmentfault.com/a/1190000012669504)
[mysql的锁--行锁，表锁，乐观锁，悲观锁](https://www.cnblogs.com/deliver/p/5730616.html)
[MySQL MVCC原理](https://www.cnblogs.com/chinesern/p/7592537.html)
[使用mysql悲观锁解决并发问题](https://www.cnblogs.com/laoyeye/p/8228467.html)
[MySQL乐观锁在分布式场景下的实践](https://segmentfault.com/a/1190000008935924)
[mysql乐观锁总结和实践](https://www.2cto.com/database/201704/632115.html)
[Mysql加锁过程详解（7）-初步理解MySQL的gap锁](https://www.cnblogs.com/crazylqy/p/7689447.html)