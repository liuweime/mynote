# MySQL 复习笔记(1): 锁

有一点 MySQL 的使用经验都应该知道 MySQL 中的锁，如表锁、行锁、间隙锁，还有什么乐观锁、悲观锁、共享锁、排他锁、意向锁等等。
虽然知道这方面的知识，但是有些知识长时间不用也有一点忘记了。

上面说了好多种锁，是按照不同分类来定义的，某种锁即可能是行锁，也可能是排他锁，或悲观锁。

如果按照锁粒度来区分锁的话，可以大致分成两种：
- 表锁：一种粒度很大的锁，会将整个数据表加锁，因此很容易发生锁冲突，并发度很低，但是加锁开销小，加锁较快；
- 行锁：较小粒度的锁，对表中某一行记录进行加锁，开销比较大，不容易发生锁冲突，但是会出现死锁情况

如果按照锁的类型来区分，又可以分成共享锁和排他锁：

**共享锁**

又称为读锁、S 锁，该记录被加 S 锁后，事务未提交之前，其他事务只能读取，而不能修改（所以又被称为读锁），不过不影响其他事务在该记录加 S 锁（所以称为共享锁）；但是，不能加排他锁。

加入 S 锁后，其他事务不能修改该记录，不是因为 S 锁禁止修改，而是因为 update、delete 等修改操作需要在记录上加入排他锁，而不同事务添加 X 锁必须建立在本身没有锁的前提下。

主动加 S 锁的命令是 `lock in share mode`，如下：

```sql
SELECT * FROM `test` WHERE id = 1 LOCK IN SHARE MODE;
```

**排它锁**

又被称为写锁、X 锁、独占锁，被加锁后，其他事务不允许获取到锁，且其他锁在加锁事务提交之前不能修改记录。

update、delete 会对记录加 X 锁，主动加锁使用`for update`命令，如下：

```sql
SELECT * FROM `test` WHERE id = 1 FOR UPDATE
```

排他锁和共享锁都是属于行锁，如果在名称之前加一个 **意向** 前缀，那就是属于表锁了。

**意向共享锁**

**意向排它锁**







