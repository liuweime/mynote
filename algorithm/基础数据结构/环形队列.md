---
flag: blue
---

# 环形队列

队列是一种先进先出的数据结构，环形队列是一个固定大小，首尾相连的队列，通常用来缓存数据。环形队列特点是取出数据，剩余数据不需要移动位置，所以数据存取速度较快。

如果采用数组实现，需要解决的问题是：

1、如何将数组的首尾相连。
解决方式是通过取模实现，写指针加1对数组长度取模即为下一个节点的位置`tail = (tail + 1) % N`。

2、判断队列是否为空或是否已经充满。

方法一：读写共享标志位。
添加操作中，如果写指针等于读指针，就将标志位置为1，表示队列已满；
读取操作中，如果读指针等于写指针，就将标志位置为0，表示队列已空；
判断空或满时，判断读写指针是否相等和标志位即可。
缺点：并发问题

方法二：数据计数
内置一个size计数器，添加size自增，读取时，size自减。
缺点：并发问题

方法三：保持队列中一个存储单元为空
读指针保持正常操作，当读指针等于写指针，说明队列为空；
需要保证写指针永远追不上读指针，方法：利用取模值判断，当取模值等于读指针时，表示队列已满。
`tail = (tail + 1) % N`是下一个节点，所以会永远存在一个空的存储单元。
缺点：队列中长度与实际长度不一致。

方法四：读写计数器
方法二的升级版，计数器分成读、写计数器，分开计数，两者差值为0表示队列已满，两者差值等于队列长度说明队列为空。
缺点：需要维护两个计数器

方法五：kfifo队列
对方法三的升级，保证队列长度N=2^n，读写指针相等表示队列为空，读写指针之差等于N表示队列为满；同时，使用读写指针按位与队列长度-1的方式获取读写位置，即`tail & (N - 1)`。

```Java
// init
if (size & (size - 1)) {
  int num = 1;
  while(num < size) {
    num = num << 1;
  }
  N = num;
} else {
  N = size;
}

// write
buffer[tail & (N-1)] = item;
tail++;

// read
String item = buffer[head & (N-1)];
head++;

// size
int size = tail - head;
```

解释：

- 为啥要去队列长度为2的幂
答：当长度为2的幂时，按位与运算命中读写位置最高。如：N = 7，N-1 的二进制位 `0000 0110`，命中`0,2,4,6`4个索引值，而N = 8时，可以命中全部索引。

- 如何判断队列长度是否为2的幂
答：公式 size & (size - 1)，非0即不是2的幂。原因：若是2的幂，二进制必有且只有一位为1，减1后1的位置必为0，按位与的结果必为0。

- 如何向上拓展为2的幂
答：将1按位右移，直到其值大于原值。

- 读写指针溢出问题
答：在C中可以设置其为无符号整型，+1溢出后会回到0；在Java中没有无符号的声明，int 溢出后回到`-2147483648`

方法六：数据镜像
如果不希望指针不停增长，不限制数组长度为2的幂，采取数据镜像位的方式。实际长度为N，拓展为2N，地址空间即为0 ~ 2N-1，0~N-1为实际地址，N~2N-1为镜像地址。寻址方式不变，指针增长公式变为`(pointer+1) & (2N - 1)`。
读写指针相等表示队列为空，读写指针之差等于队列长度表示队列已满。

运用之一：
- 运用在限流器中
使用令牌桶实现的限流器，当令牌不足时，将多余请求放入环形缓冲队列中。

